<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Brillouin.jl</title><link rel="canonical" href="https://thchr.github.io/Brillouin.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Brillouin.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Brillouin.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Brillouin.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../wignerseitz/">Wigner–Seitz cells</a></li><li><a class="tocitem" href="../kpaths/">k-space paths</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Exported-methods"><span>Exported methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thchr/Brillouin.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><hr/><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Brillouin.WignerSeitz.Cell" href="#Brillouin.WignerSeitz.Cell"><code>Brillouin.WignerSeitz.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Cell{D} &lt;: AbstractArray{Array{StaticArrays.SArray{Tuple{D}, Float64, 1, D}, 1}, 1}</code></pre><ul><li><p><code>verts::Array{StaticArrays.SVector{D, Float64}, 1} where D</code></p></li><li><p><code>faces::Vector{Vector{Int64}}</code></p></li><li><p><code>basis::StaticArrays.SArray{Tuple{D}, StaticArrays.SVector{D, Float64}, 1, D} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/WignerSeitz.jl#LL28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.KPath" href="#Brillouin.KPaths.KPath"><code>Brillouin.KPaths.KPath</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KPath{D} &lt;: Brillouin.KPaths.AbstractPath{Pair{Symbol, StaticArrays.SArray{Tuple{D}, Float64, 1, D}}}</code></pre><ul><li><p><code>points::Dict{Symbol, StaticArrays.SVector{D, Float64}} where D</code></p></li><li><p><code>paths::Vector{Vector{Symbol}}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.KPathInterpolant" href="#Brillouin.KPaths.KPathInterpolant"><code>Brillouin.KPaths.KPathInterpolant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KPathInterpolant{D} &lt;: Brillouin.KPaths.AbstractPath{StaticArrays.SArray{Tuple{D}, Float64, 1, D}}</code></pre><ul><li><p><code>kpaths::Array{Array{StaticArrays.SVector{D, Float64}, 1}, 1} where D</code></p></li><li><p><code>labels::Vector{Dict{Int64, Symbol}}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL21">source</a></section></article><h2 id="Exported-methods"><a class="docs-heading-anchor" href="#Exported-methods">Exported methods</a><a id="Exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Brillouin.WignerSeitz.wignerseitz-Union{Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real)}, Tuple{D}} where D" href="#Brillouin.WignerSeitz.wignerseitz-Union{Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real)}, Tuple{D}} where D"><code>Brillouin.WignerSeitz.wignerseitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wignerseitz(Vs::AbstractVector{&lt;:SVector{D}}; merge::Bool = true, Nmax = 3)
wignerseitz(Vs::AbstractVector{AbstractVector}; merge::Bool = true, Nmax = 3)
                                                            --&gt; Cell{D}</code></pre><p>Return a <code>Cell{D}</code> structure, containing the vertices and associated (outward oriented) faces, of the Wigner-Seitz cell defined by a basis <code>Vs</code> in <code>D</code> dimensions.</p><p><strong>Keyword arguments</strong></p><ul><li><code>merge</code> (default, <code>true</code>): if <code>true</code>, co-planar faces are merged to form polygonal planar faces (e.g., triangles, quadrilaterals, and ngons generally). If <code>false</code>, raw &quot;unprocessed&quot; triangles (<code>D=3</code>) and segments (<code>D=2</code>) are returned instead. <code>merge</code> has no impact for <code>D=1</code>.</li><li><code>Nmax</code> (default, <code>3</code>): includes <code>-Nmax:Nmax</code> points in the initial lattice used to generate the underlying Voronoi tesselation. It is unwise to set this to anything lower than 3 without explicitly testing convergence; and probably unnecessary to increase it beyond 3 as well.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/WignerSeitz.jl#LL67-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D" href="#Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D"><code>Brillouin.KPaths.cartesianize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesianize!(kpi::KPathInterpolant{D}, Gs::BasisLike)</code></pre><p>Transform an interpolated <strong>k</strong>-path <code>kpi</code> in a lattice basis to a Cartesian basis with (primitive) reciprocal lattice vectors <code>Gs</code>. Modifies <code>kpi</code> in-place.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>If <code>kpi</code> was originally created from a <code>KPath</code> in a non-cartesian basis, its points will not be equidistantly spaced when converted to a Cartesian basis. In particular, for a <code>kp::KPath</code> in the lattice basis, it is generally true that <code>interpolate(cartesianize(kp, pGs), N) ≠ cartesianize(interpolate(kp, N), pGs))</code>, unless the reciprocal basis <code>pGs</code> is square. Only <code>interpolate(cartesianize(kp, pGs)</code> is guaranteed to produce paths that are approximately equidistantly spaced.</p><p>It is therefore strongly recommended <em>not</em> to use <code>cartesianize!(::KPathInterpolant)</code> except in combination with <a href="#Brillouin.KPaths.latticize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D"><code>latticize!(::KPathInterpolant)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL56-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPath{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}} where D" href="#Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPath{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}} where D"><code>Brillouin.KPaths.cartesianize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesianize!(kp::KPath{D}, Gs::BasisLike{D})</code></pre><p>Transform a <strong>k</strong>-path <code>kp</code> in a lattice basis to a Cartesian basis with (primitive) basis vectors <code>Gs</code>. Modifies <code>kp</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.interpolate-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real), Integer}" href="#Brillouin.KPaths.interpolate-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real), Integer}"><code>Brillouin.KPaths.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolate(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, N::Integer)
    --&gt; Vector{&lt;:Vector{&lt;:Real}}</code></pre><p>Return an interpolated <strong>k</strong>-path between discrete <strong>k</strong>-points in <code>kvs</code>, with approximately <code>N</code> interpolation points in total (typically fewer).</p><p>Note that, in general, it is not possible to do this so that all interpolated <strong>k</strong>-points are equidistant; samples are however <em>exactly</em> equidistant across each linear segment defined by points in <code>kvs</code> and <em>approximately</em> equidistant across all segments.</p><p>See also <a href="#Brillouin.KPaths.interpolate-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real), Integer}"><code>interpolate(::KPath, ::Integer)</code></a> and <a href="#Brillouin.KPaths.splice-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real), Integer}"><code>splice</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL164-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.interpolate-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D" href="#Brillouin.KPaths.interpolate-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D"><code>Brillouin.KPaths.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolate(kp::KPath, N::Integer) --&gt; KPathInterpolant</code></pre><p>Return an interpolant of <code>kp</code> with approximately <code>N</code> points distributed approximately equidistantly across the full <strong>k</strong>-path.</p><p>Note that the interpolant may contain fewer or more points than <code>N</code> (typically fewer). </p><p>See also <a href="@ref"><code>interpolate(::AbstractVector{::AbstractVector{&lt;:Real}}, ::Integer)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL98-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.irrfbz_path-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Union{Nothing, AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}, Tuple{Integer, Union{Nothing, AbstractVector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:(AbstractVector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real)}, Val{D}}} where D" href="#Brillouin.KPaths.irrfbz_path-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Union{Nothing, AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}, Tuple{Integer, Union{Nothing, AbstractVector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:(AbstractVector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real)}, Val{D}}} where D"><code>Brillouin.KPaths.irrfbz_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">irrfbz_path(sgnum::Integer,
            Rs::Union{Nothing, AVec{&lt;:AVec{&lt;:Real}}}=nothing,
            [::Union{Val(D), Integer},]=Val(3))                     --&gt;  ::KPath{D}</code></pre><p>Returns a <strong>k</strong>-path (<code>::KPath</code>) in the (primitive) irreducible Brillouin zone that includes all distinct high-symmetry lines and points as well as relevant parts of the Brillouin zone boundary.</p><p>The dimension <code>D</code> (1, 2, or 3) is specified as the third input argument, preferably as a static <code>Val{D}</code> type parameter (or, type-unstably, as an <code>&lt;:Integer</code>). Defaults to <code>Val(3)</code>.</p><p><code>Rs</code> refers to the direct basis of the conventional unit cell. For some space groups, it is needed to disambiguate the &quot;extended&quot; Bravais types that may differ depending on the lengths of the lattice vectors (because the Brillouin zone may depend on these lengths). If the requested space group is known to not fall under this case, <code>Rs</code> can be supplied as <code>nothing</code> (default). If <code>Rs</code> is a subtype of a <a href="@ref"><code>StaticVector</code></a>, the dimension can be inferred from its (static) size; no explicit input of dimension is needed in this case.</p><p><strong>Notes</strong></p><ul><li>The returned <strong>k</strong>-points are given in the basis of the <strong>primitive</strong> reciprocal basis (see <a href="#Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D"><code>cartesianize!</code></a>).</li><li>To interpolate a <code>KPath</code>, see <a href="#Brillouin.KPaths.interpolate-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real), Integer}"><code>interpolate(::KPath, ::Integer)</code></a> and <a href="#Brillouin.KPaths.splice-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real), Integer}"><code>splice(::KPath, ::Integer)</code></a>.</li><li>All paths currently assume time-reversal symmetry (or, equivalently, inversion symmetry). If neither are present, include the &quot;inverted&quot; -<strong>k</strong> paths manually.</li></ul><p><strong>Data and referencing</strong></p><p>3D paths are sourced from the SeeK HPKOT publication: please cite the original work <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> Hinuma, Pizzi, Kumagai, Oba, &amp; Tanaka, <em>Band structure diagram paths based on      crystallography</em>,       <a href="http://dx.doi.org/10.1016/j.commatsci.2016.10.015">Comp. Mat. Sci. <strong>128</strong>, 140 (2017)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL99-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.latticize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D" href="#Brillouin.KPaths.latticize!-Union{Tuple{D}, Tuple{KPathInterpolant{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real)}}} where D"><code>Brillouin.KPaths.latticize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">latticize!(kpi::KPathInterpolant{D}, Gs::BasisLike)</code></pre><p>Transform an interpolated <strong>k</strong>-path <code>kpi</code> in a Cartesian basis to a lattice basis with (primitive) reciprocal lattice vectors <code>Gs</code>. Modifies <code>kpi</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.latticize!-Union{Tuple{D}, Tuple{KPath{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}} where D" href="#Brillouin.KPaths.latticize!-Union{Tuple{D}, Tuple{KPath{D}, Union{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SVector{D, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real)}}} where D"><code>Brillouin.KPaths.latticize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">latticize!(kp::KPath{D}, Gs::BasisLike{D})</code></pre><p>Transform a <strong>k</strong>-path <code>kpi</code> in a Cartesian basis to a lattice basis with (primitive) reciprocal lattice vectors <code>Gs</code>. Modifies <code>kp</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.paths-Tuple{KPath}" href="#Brillouin.KPaths.paths-Tuple{KPath}"><code>Brillouin.KPaths.paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">paths(kp::KPath) -&gt; Vector{Vector{Symbol}}</code></pre><p>Return a vector of vectors, with each vector describing a connected path between between <strong>k</strong>-points referenced in <code>kp</code> (see also <a href="#Brillouin.KPaths.points-Tuple{KPath}"><code>points(::KPath)</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.points-Tuple{KPath}" href="#Brillouin.KPaths.points-Tuple{KPath}"><code>Brillouin.KPaths.points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">points(kp::KPath{D}) -&gt; Dict{Symbol, SVector{D,Float64}}</code></pre><p>Return a dictionary of the <strong>k</strong>-points (values) and associated <strong>k</strong>-labels (keys) referenced in <code>kp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/KPaths.jl#LL39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.splice-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real), Integer}" href="#Brillouin.KPaths.splice-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real), Integer}"><code>Brillouin.KPaths.splice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splice(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, N::Integer)
    --&gt; Vector{&lt;:Vector{&lt;:Real}}</code></pre><p>Return an interpolated <strong>k</strong>-path between the discrete <strong>k</strong>-points in <code>kvs</code>, with <code>N</code> interpolation points inserted in each segment defined by pairs of adjacent <strong>k</strong>-points.</p><p>See also <a href="#Brillouin.KPaths.splice-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real), Integer}"><code>splice(::KPath, ::Integer)</code></a> and <a href="#Brillouin.KPaths.interpolate-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real), Integer}"><code>interpolate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL199-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.splice-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D" href="#Brillouin.KPaths.splice-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D"><code>Brillouin.KPaths.splice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splice(kp::KPath, N::Integer) --&gt; KPathInterpolant</code></pre><p>Return an interpolant of <code>kp</code> with <code>N</code> points inserted into each <strong>k</strong>-path segment of <code>kp</code>.</p><p>See also <a href="@ref"><code>splice(::AbstractVector{::AbstractVector{&lt;:Real}}, ::Integer)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Brillouin.jl/blob/f1823c358dc6b95d2095154fb3f146b5d9b9c679/src/interpolate-paths.jl#LL134-L140">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../kpaths/">« k-space paths</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 May 2021 18:02">Tuesday 25 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
