var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Brillouin","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Brillouin.WignerSeitz.Cell\nBrillouin.KPaths.KPath\nBrillouin.KPaths.KPathInterpolant","category":"page"},{"location":"api/#Exported-methods","page":"API","title":"Exported methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Brillouin.WignerSeitz, Brillouin.KPaths]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Brillouin.WignerSeitz.wignerseitz-Union{Tuple{AbstractVector{var\"#s4\"} where var\"#s4\"<:(StaticArrays.SVector{D, var\"#s3\"} where var\"#s3\"<:Real)}, Tuple{D}} where D","page":"API","title":"Brillouin.WignerSeitz.wignerseitz","text":"wignerseitz(Vs::AbstractVector{<:SVector{D}}; merge::Bool = true, Nmax = 3)\nwignerseitz(Vs::AbstractVector{AbstractVector}; merge::Bool = true, Nmax = 3)\n                                                            --> Cell{D}\n\nReturn a Cell{D} structure, containing the vertices and associated (outward oriented) faces, of the Wigner-Seitz cell defined by a basis Vs in D dimensions.\n\nKeyword arguments\n\nmerge (default, true): if :true, co-planar faces are merged to form polygonal planar faces (e.g., triangles, quadrilaterals, and ngons generally). If false, raw \"unprocessed\" triangles (D=3) and segments (D=2) are returned instead. merge has no impact for D=1.\nNmax (default, 3): includes -Nmax:Nmax points in the initial lattice used to generate the underlying Voronoi tesselation. It is unwise to set this to anything lower than 3 without explicitly testing convergence; and probably unnecessary to increase it beyond 3 as well.\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.cartesianize!-Union{Tuple{D}, Tuple{KPath{D}, Union{AbstractVector{var\"#s1\"} where var\"#s1\"<:(StaticArrays.SVector{D, var\"#s2\"} where var\"#s2\"<:Real), AbstractVector{var\"#s9\"} where var\"#s9\"<:(AbstractVector{var\"#s8\"} where var\"#s8\"<:Real)}}} where D","page":"API","title":"Brillouin.KPaths.cartesianize!","text":"cartesianize!(kp::KPath, Gs::BasisLike)\n\nTransform a k-path kp to a Cartesian coordinate system using a primitive basis Gs. Modifies the underlying dictionary in kp in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.interpolate-Tuple{AbstractVector{var\"#s9\"} where var\"#s9\"<:(AbstractVector{var\"#s8\"} where var\"#s8\"<:Real), Integer}","page":"API","title":"Brillouin.KPaths.interpolate","text":"interpolate(kvs::AbstractVector{<:AbstractVector{<:Real}}, N::Integer)\n    --> Vector{<:Vector{<:Real}}\n\nReturn an interpolated k-path between discrete k-points in kvs, with approximately N interpolation points in total (typically fewer).\n\nNote that, in general, it is not possible to do this so that all interpolated k-points are equidistant; samples are however exactly equidistant across each linear segment defined by points in kvs and approximately equidistant across all segments.\n\nSee also interpolate(::KPath, ::Integer) and splice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.interpolate-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D","page":"API","title":"Brillouin.KPaths.interpolate","text":"interpolate(kp::KPath, N::Integer) --> KPathInterpolant\n\nReturn an interpolant of kp with approximately N points distributed approximately equidistantly across the full k-path.\n\nNote that the interpolant may contain fewer or more points than N (typically fewer). \n\nSee also interpolate(::AbstractVector{::AbstractVector{<:Real}}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.irrfbz_path","page":"API","title":"Brillouin.KPaths.irrfbz_path","text":"irrfbz_path(sgnum::Integer, Rs::Union{Nothing, AbstractVector{var\"#s1\"} where {D, var\"#s1\"<:(StaticArrays.SVector{D, var\"#s2\"} where var\"#s2\"<:Real)}}=nothing)   -->  ::KPath\n\nReturns a k-path (::KPath) in the (primitive) irreducible Brillouin zone that includes all distinct high-symmetry lines and points as well as parts of the Brillouin zone boundary.\n\nRs refers to the direct basis of the conventional unit cell. For some space groups, it is needed to disambiguate the \"extended\" Bravais types that may differ depending on the lengths of the lattice vectors (because the Brillouin zone may depend on these lengths). If the requested space group is known to not fall under this case, Rs can be supplied as nothing (default).\n\nNote that the returned k-points are given in the basis of the primitive reciprocal basis (see cartesianize!).\n\nTo interpolate the resulting KPath, see interpolate(::KPath, ::Integer) and splice(::KPath, ::Integer).\n\nData and referencing\n\nAll data is sourced from the SeeK HPKOT publication[1]: please cite the original work.\n\nAll paths currently assume time-reversal symmetry (or, equivalently, inversion symmetry),  corresponding to the SeeK's [with inversion] setting. If neither inversion nor time-reversal, include the \"inverted\" **-k* paths as well manually.\n\n[1] Hinuma, Pizzi, Kumagai, Oba, & Tanaka, Band structure diagram paths based on     crystallography,      Comp. Mat. Sci. 128, 140 (2017)\n\n\n\n\n\n","category":"function"},{"location":"api/#Brillouin.KPaths.paths-Tuple{KPath}","page":"API","title":"Brillouin.KPaths.paths","text":"paths(kp::KPath) -> Dict{Symbol, SVector{D,Float64}}\n\nReturn a vector of vectors, with each vector describing a connected path between between k-points referenced in kp (see also points(::KPath)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.points-Tuple{KPath}","page":"API","title":"Brillouin.KPaths.points","text":"points(kp::KPath) -> Dict{Symbol, SVector{D,Float64}}\n\nReturn a dictionary of the k-points (values) and associated k-labels (keys) referenced in kp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.splice-Tuple{AbstractVector{var\"#s10\"} where var\"#s10\"<:(AbstractVector{var\"#s9\"} where var\"#s9\"<:Real), Integer}","page":"API","title":"Brillouin.KPaths.splice","text":"splice(kvs::AbstractVector{<:AbstractVector{<:Real}}, N::Integer)\n    --> Vector{<:Vector{<:Real}}\n\nReturn an interpolated k-path between the discrete k-points in kvs, with N interpolation points inserted in each segment defined by pairs of adjacent k-points.\n\nSee also splice(::KPath, ::Integer) and interpolate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Brillouin.KPaths.splice-Union{Tuple{D}, Tuple{KPath{D}, Integer}} where D","page":"API","title":"Brillouin.KPaths.splice","text":"splice(kp::KPath, N::Integer) --> KPathInterpolant\n\nReturn an interpolant of kp with N points inserted into each k-path segment of kp.\n\nSee also splice(::AbstractVector{::AbstractVector{<:Real}}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"kpaths/#**k**-space-paths","page":"k-space paths","title":"k-space paths","text":"","category":"section"},{"location":"kpaths/#Default-paths","page":"k-space paths","title":"Default paths","text":"","category":"section"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"To generate a k-path for, say, the space group of diamond (space group 227; a cubic face-centered Bravais lattice), we can call irrfbz_path, which will return a minimal path in the irreducible Brillouin zone:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"using Brillouin\nsgnum = 227\nRs = [[1,0,0], [0,1,0], [0,0,1]] # conventional direct basis\nkp = irrfbz_path(sgnum, Rs)","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"The path data is sourced from the HPKOT paper (or, equivalently, the SeeK-path Python package).","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"The resulting KPath structure initially gives the k-point coordinates in the basis of the primitive reciprocal basis. To convert to a Cartesian basis, we use cartesianize!:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"pGs = 2π.*[[-1,1,1], [1,-1,1], [1,1,-1]] # primitive reciprocal basis\ncartesianize!(kp, pGs)","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"We can visualize the k-path using PlotlyJS.jl:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"using PlotlyJS\nPᵏ = plot(kp)\nMain.HTMLPlot(Pᵏ) # hide","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"Usually, it'll be more helpful to understand the path's geometry in the context of the associated Brillouin zone. To visualize this, we can plot the combination of a Cell (created via wignerseitz) and a KPath:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"c = wignerseitz(pGs)\nPᶜ⁺ᵏ = plot(c, kp)\nMain.HTMLPlot(Pᶜ⁺ᵏ) # hide","category":"page"},{"location":"kpaths/#Interpolation","page":"k-space paths","title":"Interpolation","text":"","category":"section"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"Interpolation of a KPath structure can be achieved using either interpolate(::KPath, ::Integer) or splice(::KPath, ::Integer), returning a KPathInterpolant. As an example, interpolate(kp, N) returns an interpolation with a target of N interpolation points, distributed as equidistantly as possible:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"kpi = interpolate(kp, 100)","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"The returned KPathInterpolant implements the AbstractVector interface, whose iterants return SVector{D, Float64} elements. To get a conventional \"flat\" vector, we can simply call collect(kpi). Internally, KPathInterpolantincludes additional structure, however, e.g. the high-symmetry points and associated labels along the path, as well as the segmentation into connected vs. disconnected paths.","category":"page"},{"location":"kpaths/#Band-structure","page":"k-space paths","title":"Band structure","text":"","category":"section"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"The additional structure in KPathInterpolations enable convenient and clear visualization of band structure diagrams.","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"To illustrate this, suppose we are considering a tight-binding problem for an s-orbital situated at the 1a Wyckoff position. Such a problem has a single band with dispersion [1] (assuming a cubic side length a = 1):","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"epsilon(mathbfk) =\n4gammaBigl(\n    cos tfrac12k_x cos tfrac12k_y +\n    cos tfrac12k_y cos tfrac12k_z +\n    cos tfrac12k_z cos tfrac12k_x\n    Bigr)","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"We can calculate the associated energy band along our earlier k-path interpolation kpi easily:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"function ε(k; γ::Real=1.0)\n    4γ * (cos(k[1]/2)*cos(k[2]/2) + cos(k[2]/2)*cos(k[3]/2) + cos(k[3]/2)*cos(k[1]/2))\nend\nband = ε.(kpi)","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"And we can then visualize the associated band via an overloaded PlotlyJS plot call:","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"P = plot(kpi, [band])\nMain.HTMLPlot(P, 525) # hide","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"If we have multiple bands, say epsilon_1(mathbfk) = epsilon(mathbfk) and epsilon_2(mathbfk) = 20 - tfrac12epsilon(mathbfk), we can easily plot that by collecting the bands in a single vector (or concatenating into a matrix):","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"band1 = ε.(kpi)\nband2 = 20 .- (1/2).*band1\nP¹² = plot(kpi, [band1, band2])\nMain.HTMLPlot(P¹², 525) # hide","category":"page"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"plot(::KPathInterpolant, ::Any, ::Layout)","category":"page"},{"location":"kpaths/#PlotlyJS.plot-Tuple{KPathInterpolant, Any, Layout}","page":"k-space paths","title":"PlotlyJS.plot","text":"plot(kpi::KPathInterpolant, bands, [layout]; kwargs...)\n\nPlot a dispersion diagram for provided bands and k-path interpolant kpi.\n\nbands must be an iterable of iterables of <:Reals (e.g., a Vector{Vector{Float64}}), with the first iteration being running over distinct energy bands, and the second running over distinct k-points in kpi. Note that the length of each iterant of bands must equal length(kpi).\n\nAlternatively, bands can be a AbstractMatrix{<:Real}, with columns interpreted as distinct energy bands and rows as distinct k-points.\n\nKeyword arguments\n\nylims: y-axis limits (default: quasi-tight around bands's range)\nylabel: y-axis label (default: \"Energy\")\n\n\n\n\n\n","category":"method"},{"location":"kpaths/","page":"k-space paths","title":"k-space paths","text":"[1] See e.g. http://www.physics.rutgers.edu/~eandrei/chengdu/reading/tight-binding.pdf","category":"page"},{"location":"wignerseitz/#Wigner–Seitz-cells","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"","category":"section"},{"location":"wignerseitz/#Unit-cells","page":"Wigner–Seitz cells","title":"Unit cells","text":"","category":"section"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"The Wigner–Seitz cell associated with an arbitrary lattice basis can be generated via wignerseitz. For example, to generate the unit cell of a (primitive) lattice with Bravais type cF, we might write:","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"using Brillouin\n\nRs = [[0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0]]\ncᴿ = wignerseitz(Rs)","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"We can plot the generated cells using e.g. PlotlyJS.jl via plot(cᴿ) (or, alternatively, via a 3D-capable backend of AbstractPlotting.jl):","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"using PlotlyJS\nPᴿ = plot(cᴿ)\nMain.HTMLPlot(Pᴿ) # hide","category":"page"},{"location":"wignerseitz/#Brillouin-zones","page":"Wigner–Seitz cells","title":"Brillouin zones","text":"","category":"section"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"To generate Brillouin zones, we simply give the corresponding reciprocal lattice Gs:","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"Gs = 2π.*[[-1.0, 1.0, 1.0], [1.0, -1.0, 1.0], [1.0, 1.0, -1.0]] # reciprocal basis of `Rs`\ncᴳ = wignerseitz(Gs)\nPᴳ = plot(cᴳ)\nMain.HTMLPlot(Pᴳ) # hide","category":"page"},{"location":"wignerseitz/#Two-dimensions","page":"Wigner–Seitz cells","title":"Two dimensions","text":"","category":"section"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"wignerseitz and plot(::Cell) works in two dimensions as well. As an example, we can illustrate the Wigner–Seitz unit cell of graphene (which has a hexagonal \"hp\" Bravais type):","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"using Brillouin, PlotlyJS\n\nRs = [[1.0, 0.0], [-0.5, √3/2]]\ncᴿ = wignerseitz(Rs)\nPᴿ = plot(cᴿ)\nMain.HTMLPlot(Pᴿ) # hide","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"and its associated Brillouin zone:","category":"page"},{"location":"wignerseitz/","page":"Wigner–Seitz cells","title":"Wigner–Seitz cells","text":"Gs = 2π.*[[1.0, 1/√3], [0.0, 2/√3]]\ncᴳ = wignerseitz(Gs)\nPᴳ = plot(cᴳ)\nMain.HTMLPlot(Pᴳ) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Brillouin","category":"page"},{"location":"#Brillouin.jl","page":"Home","title":"Brillouin.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Brillouin.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"wignerseitz.md\",\n         \"kpaths.md\",\n         \"api.md\"]","category":"page"}]
}
